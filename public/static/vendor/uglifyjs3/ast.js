"use strict";function DEFNODE(j,a,b,c){4>arguments.length&&(c=AST_Node),a=a?a.split(/\s+/):[];var d=a;c&&c.PROPS&&(a=a.concat(c.PROPS));for(var e="return function AST_"+j+"(props){ if (props) { ",f=a.length;0<=--f;)e+="this."+a[f]+" = props."+a[f]+";";var g=c&&new c;(g&&g.initialize||b&&b.initialize)&&(e+="this.initialize();"),e+="}}";var h=new Function(e)();if(g&&(h.prototype=g,h.BASE=c),c&&c.SUBCLASSES.push(h),h.prototype.CTOR=h,h.PROPS=a||null,h.SELF_PROPS=d,h.SUBCLASSES=[],j&&(h.prototype.TYPE=h.TYPE=j),b)for(f in b)HOP(b,f)&&(/^\$/.test(f)?h[f.substr(1)]=b[f]:h.prototype[f]=b[f]);return h.DEFMETHOD=function(c,a){this.prototype[c]=a},"undefined"!=typeof exports&&(exports["AST_"+j]=h),h}var AST_Token=DEFNODE("Token","type value line col pos endline endcol endpos nlb comments_before comments_after file raw",{},null),AST_Node=DEFNODE("Node","start end",{_clone:function(c){if(c){var d=this.clone();return d.transform(new TreeTransformer(function(b){if(b!==d)return b.clone(!0)}))}return new this.CTOR(this)},clone:function(b){return this._clone(b)},$documentation:"Base class of all AST nodes",$propdoc:{start:"[AST_Token] The first token of this node",end:"[AST_Token] The last token of this node"},_walk:function(b){return b._visit(this)},walk:function(b){return this._walk(b)}},null);AST_Node.warn_function=null,AST_Node.warn=function(c,a){AST_Node.warn_function&&AST_Node.warn_function(string_template(c,a))};var AST_Statement=DEFNODE("Statement",null,{$documentation:"Base class of all statements"}),AST_Debugger=DEFNODE("Debugger",null,{$documentation:"Represents a debugger statement"},AST_Statement),AST_Directive=DEFNODE("Directive","value quote",{$documentation:"Represents a directive, like \"use strict\";",$propdoc:{value:"[string] The value of this directive as a plain string (it's not an AST_String!)",quote:"[string] the original quote character"}},AST_Statement),AST_SimpleStatement=DEFNODE("SimpleStatement","body",{$documentation:"A statement consisting of an expression, i.e. a = 1 + 2",$propdoc:{body:"[AST_Node] an expression node (should not be instanceof AST_Statement)"},_walk:function(b){return b._visit(this,function(){this.body._walk(b)})}},AST_Statement);function walk_body(f,a){var b=f.body;if(b instanceof AST_Node)b._walk(a);else for(var c=0,d=b.length;c<d;c++)b[c]._walk(a)}var AST_Block=DEFNODE("Block","body",{$documentation:"A body of statements (usually bracketed)",$propdoc:{body:"[AST_Statement*] an array of statements"},_walk:function(b){return b._visit(this,function(){walk_body(this,b)})}},AST_Statement),AST_BlockStatement=DEFNODE("BlockStatement",null,{$documentation:"A block statement"},AST_Block),AST_EmptyStatement=DEFNODE("EmptyStatement",null,{$documentation:"The empty statement (empty block or simply a semicolon)"},AST_Statement),AST_StatementWithBody=DEFNODE("StatementWithBody","body",{$documentation:"Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",$propdoc:{body:"[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"}},AST_Statement),AST_LabeledStatement=DEFNODE("LabeledStatement","label",{$documentation:"Statement with a label",$propdoc:{label:"[AST_Label] a label definition"},_walk:function(b){return b._visit(this,function(){this.label._walk(b),this.body._walk(b)})},clone:function(e){var a=this._clone(e);if(e){var b=a.label,c=this.label;a.walk(new TreeWalker(function(d){d instanceof AST_LoopControl&&d.label&&d.label.thedef===c&&(d.label.thedef=b,b.references.push(d))}))}return a}},AST_StatementWithBody),AST_IterationStatement=DEFNODE("IterationStatement",null,{$documentation:"Internal class.  All loops inherit from it."},AST_StatementWithBody),AST_DWLoop=DEFNODE("DWLoop","condition",{$documentation:"Base class for do/while statements",$propdoc:{condition:"[AST_Node] the loop condition.  Should not be instanceof AST_Statement"}},AST_IterationStatement),AST_Do=DEFNODE("Do",null,{$documentation:"A `do` statement",_walk:function(b){return b._visit(this,function(){this.body._walk(b),this.condition._walk(b)})}},AST_DWLoop),AST_While=DEFNODE("While",null,{$documentation:"A `while` statement",_walk:function(b){return b._visit(this,function(){this.condition._walk(b),this.body._walk(b)})}},AST_DWLoop),AST_For=DEFNODE("For","init condition step",{$documentation:"A `for` statement",$propdoc:{init:"[AST_Node?] the `for` initialization code, or null if empty",condition:"[AST_Node?] the `for` termination clause, or null if empty",step:"[AST_Node?] the `for` update clause, or null if empty"},_walk:function(b){return b._visit(this,function(){this.init&&this.init._walk(b),this.condition&&this.condition._walk(b),this.step&&this.step._walk(b),this.body._walk(b)})}},AST_IterationStatement),AST_ForIn=DEFNODE("ForIn","init object",{$documentation:"A `for ... in` statement",$propdoc:{init:"[AST_Node] the `for/in` initialization code",object:"[AST_Node] the object that we're looping through"},_walk:function(b){return b._visit(this,function(){this.init._walk(b),this.object._walk(b),this.body._walk(b)})}},AST_IterationStatement),AST_ForOf=DEFNODE("ForOf",null,{$documentation:"A `for ... of` statement"},AST_ForIn),AST_With=DEFNODE("With","expression",{$documentation:"A `with` statement",$propdoc:{expression:"[AST_Node] the `with` expression"},_walk:function(b){return b._visit(this,function(){this.expression._walk(b),this.body._walk(b)})}},AST_StatementWithBody),AST_Scope=DEFNODE("Scope","variables functions uses_with uses_eval parent_scope enclosed cname",{$documentation:"Base class for all statements introducing a lexical scope",$propdoc:{variables:"[Object/S] a map of name -> SymbolDef for all variables/functions defined in this scope",functions:"[Object/S] like `variables`, but only lists function declarations",uses_with:"[boolean/S] tells whether this scope uses the `with` statement",uses_eval:"[boolean/S] tells whether this scope contains a direct call to the global `eval`",parent_scope:"[AST_Scope?/S] link to the parent scope",enclosed:"[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",cname:"[integer/S] current index for mangling variables (used internally by the mangler)"},get_defun_scope:function(){for(var b=this;b.is_block_scope();)b=b.parent_scope;return b},clone:function(c){var a=this._clone(c);return this.variables&&(a.variables=this.variables.clone()),this.functions&&(a.functions=this.functions.clone()),this.enclosed&&(a.enclosed=this.enclosed.slice()),a}},AST_Block),AST_Toplevel=DEFNODE("Toplevel","globals",{$documentation:"The toplevel scope",$propdoc:{globals:"[Object/S] a map of name -> SymbolDef for all undeclared names"},wrap_commonjs:function(d){var e=this.body,a="(function(exports){'$ORIG';})(typeof "+d+"=='undefined'?("+d+"={}):"+d+");";return a=parse(a),a=a.transform(new TreeTransformer(function(b){if(b instanceof AST_Directive&&"$ORIG"==b.value)return MAP.splice(e)})),a}},AST_Scope),AST_Expansion=DEFNODE("Expansion","expression",{$documentation:"An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",$propdoc:{expression:"[AST_Node] the thing to be expanded"},_walk:function(c){var a=this;return c._visit(this,function(){a.expression.walk(c)})}}),AST_Lambda=DEFNODE("Lambda","name argnames uses_arguments is_generator async",{$documentation:"Base class for functions",$propdoc:{name:"[AST_SymbolDeclaration?] the name of this function",argnames:"[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",uses_arguments:"[boolean/S] tells whether this function accesses the arguments array",is_generator:"[boolean] is this a generator method",async:"[boolean] is this method async"},args_as_names:function(){for(var c=[],a=0;a<this.argnames.length;a++)this.argnames[a]instanceof AST_Destructuring?c=c.concat(this.argnames[a].all_symbols()):c.push(this.argnames[a]);return c},_walk:function(e){return e._visit(this,function(){this.name&&this.name._walk(e);for(var a=this.argnames,b=0,c=a.length;b<c;b++)a[b]._walk(e);walk_body(this,e)})}},AST_Scope),AST_Accessor=DEFNODE("Accessor",null,{$documentation:"A setter/getter function.  The `name` property is always null."},AST_Lambda),AST_Function=DEFNODE("Function","inlined",{$documentation:"A function expression"},AST_Lambda),AST_Arrow=DEFNODE("Arrow","inlined",{$documentation:"An ES6 Arrow function ((a) => b)"},AST_Lambda),AST_Defun=DEFNODE("Defun","inlined",{$documentation:"A function definition"},AST_Lambda),AST_Destructuring=DEFNODE("Destructuring","names is_array",{$documentation:"A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",$propdoc:{names:"[AST_Node*] Array of properties or elements",is_array:"[Boolean] Whether the destructuring represents an object or array"},_walk:function(c){return c._visit(this,function(){this.names.forEach(function(a){a._walk(c)})})},all_symbols:function(){var c=[];return this.walk(new TreeWalker(function(a){a instanceof AST_Symbol&&c.push(a),a instanceof AST_Expansion&&c.push(a.expression)})),c}}),AST_PrefixedTemplateString=DEFNODE("PrefixedTemplateString","template_string prefix",{$documentation:"A templatestring with a prefix, such as String.raw`foobarbaz`",$propdoc:{template_string:"[AST_TemplateString] The template string",prefix:"[AST_SymbolRef|AST_PropAccess] The prefix, which can be a symbol such as `foo` or a dotted expression such as `String.raw`."},_walk:function(b){this.prefix._walk(b),this.template_string._walk(b)}}),AST_TemplateString=DEFNODE("TemplateString","segments",{$documentation:"A template string literal",$propdoc:{segments:"[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."},_walk:function(c){return c._visit(this,function(){this.segments.forEach(function(a){a._walk(c)})})}}),AST_TemplateSegment=DEFNODE("TemplateSegment","value raw",{$documentation:"A segment of a template string literal",$propdoc:{value:"Content of the segment",raw:"Raw content of the segment"}}),AST_Jump=DEFNODE("Jump",null,{$documentation:"Base class for \u201Cjumps\u201D (for now that's `return`, `throw`, `break` and `continue`)"},AST_Statement),AST_Exit=DEFNODE("Exit","value",{$documentation:"Base class for \u201Cexits\u201D (`return` and `throw`)",$propdoc:{value:"[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"},_walk:function(b){return b._visit(this,this.value&&function(){this.value._walk(b)})}},AST_Jump),AST_Return=DEFNODE("Return",null,{$documentation:"A `return` statement"},AST_Exit),AST_Throw=DEFNODE("Throw",null,{$documentation:"A `throw` statement"},AST_Exit),AST_LoopControl=DEFNODE("LoopControl","label",{$documentation:"Base class for loop control statements (`break` and `continue`)",$propdoc:{label:"[AST_LabelRef?] the label, or null if none"},_walk:function(b){return b._visit(this,this.label&&function(){this.label._walk(b)})}},AST_Jump),AST_Break=DEFNODE("Break",null,{$documentation:"A `break` statement"},AST_LoopControl),AST_Continue=DEFNODE("Continue",null,{$documentation:"A `continue` statement"},AST_LoopControl),AST_If=DEFNODE("If","condition alternative",{$documentation:"A `if` statement",$propdoc:{condition:"[AST_Node] the `if` condition",alternative:"[AST_Statement?] the `else` part, or null if not present"},_walk:function(b){return b._visit(this,function(){this.condition._walk(b),this.body._walk(b),this.alternative&&this.alternative._walk(b)})}},AST_StatementWithBody),AST_Switch=DEFNODE("Switch","expression",{$documentation:"A `switch` statement",$propdoc:{expression:"[AST_Node] the `switch` \u201Cdiscriminant\u201D"},_walk:function(b){return b._visit(this,function(){this.expression._walk(b),walk_body(this,b)})}},AST_Block),AST_SwitchBranch=DEFNODE("SwitchBranch",null,{$documentation:"Base class for `switch` branches"},AST_Block),AST_Default=DEFNODE("Default",null,{$documentation:"A `default` switch branch"},AST_SwitchBranch),AST_Case=DEFNODE("Case","expression",{$documentation:"A `case` switch branch",$propdoc:{expression:"[AST_Node] the `case` expression"},_walk:function(b){return b._visit(this,function(){this.expression._walk(b),walk_body(this,b)})}},AST_SwitchBranch),AST_Try=DEFNODE("Try","bcatch bfinally",{$documentation:"A `try` statement",$propdoc:{bcatch:"[AST_Catch?] the catch block, or null if not present",bfinally:"[AST_Finally?] the finally block, or null if not present"},_walk:function(b){return b._visit(this,function(){walk_body(this,b),this.bcatch&&this.bcatch._walk(b),this.bfinally&&this.bfinally._walk(b)})}},AST_Block),AST_Catch=DEFNODE("Catch","argname",{$documentation:"A `catch` node; only makes sense as part of a `try` statement",$propdoc:{argname:"[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"},_walk:function(b){return b._visit(this,function(){this.argname._walk(b),walk_body(this,b)})}},AST_Block),AST_Finally=DEFNODE("Finally",null,{$documentation:"A `finally` node; only makes sense as part of a `try` statement"},AST_Block),AST_Definitions=DEFNODE("Definitions","definitions",{$documentation:"Base class for `var` or `const` nodes (variable declarations/initializations)",$propdoc:{definitions:"[AST_VarDef*] array of variable definitions"},_walk:function(e){return e._visit(this,function(){for(var a=this.definitions,b=0,c=a.length;b<c;b++)a[b]._walk(e)})}},AST_Statement),AST_Var=DEFNODE("Var",null,{$documentation:"A `var` statement"},AST_Definitions),AST_Let=DEFNODE("Let",null,{$documentation:"A `let` statement"},AST_Definitions),AST_Const=DEFNODE("Const",null,{$documentation:"A `const` statement"},AST_Definitions),AST_NameMapping=DEFNODE("NameMapping","foreign_name name",{$documentation:"The part of the export/import statement that declare names from a module.",$propdoc:{foreign_name:"[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",name:"[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."},_walk:function(b){return b._visit(this,function(){this.foreign_name._walk(b),this.name._walk(b)})}}),AST_Import=DEFNODE("Import","imported_name imported_names module_name",{$documentation:"An `import` statement",$propdoc:{imported_name:"[AST_SymbolImport] The name of the variable holding the module's default export.",imported_names:"[AST_NameMapping*] The names of non-default imported variables",module_name:"[AST_String] String literal describing where this module came from"},_walk:function(c){return c._visit(this,function(){this.imported_name&&this.imported_name._walk(c),this.imported_names&&this.imported_names.forEach(function(a){a._walk(c)}),this.module_name._walk(c)})}}),AST_Export=DEFNODE("Export","exported_definition exported_value is_default exported_names module_name",{$documentation:"An `export` statement",$propdoc:{exported_definition:"[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",exported_value:"[AST_Node?] An exported value",exported_names:"[AST_NameMapping*?] List of exported names",module_name:"[AST_String?] Name of the file to load exports from",is_default:"[Boolean] Whether this is the default exported value of this module"},_walk:function(c){c._visit(this,function(){this.exported_definition&&this.exported_definition._walk(c),this.exported_value&&this.exported_value._walk(c),this.exported_names&&this.exported_names.forEach(function(a){a._walk(c)}),this.module_name&&this.module_name._walk(c)})}},AST_Statement),AST_VarDef=DEFNODE("VarDef","name value",{$documentation:"A variable declaration; only appears in a AST_Definitions node",$propdoc:{name:"[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",value:"[AST_Node?] initializer, or null of there's no initializer"},_walk:function(b){return b._visit(this,function(){this.name._walk(b),this.value&&this.value._walk(b)})}}),AST_Call=DEFNODE("Call","expression args",{$documentation:"A function call expression",$propdoc:{expression:"[AST_Node] expression to invoke as function",args:"[AST_Node*] array of arguments"},_walk:function(e){return e._visit(this,function(){for(var a=this.args,b=0,c=a.length;b<c;b++)a[b]._walk(e);this.expression._walk(e)})}}),AST_New=DEFNODE("New",null,{$documentation:"An object instantiation.  Derives from a function call since it has exactly the same properties"},AST_Call),AST_Sequence=DEFNODE("Sequence","expressions",{$documentation:"A sequence expression (comma-separated expressions)",$propdoc:{expressions:"[AST_Node*] array of expressions (at least two)"},_walk:function(c){return c._visit(this,function(){this.expressions.forEach(function(a){a._walk(c)})})}}),AST_PropAccess=DEFNODE("PropAccess","expression property",{$documentation:"Base class for property access expressions, i.e. `a.foo` or `a[\"foo\"]`",$propdoc:{expression:"[AST_Node] the \u201Ccontainer\u201D expression",property:"[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"}}),AST_Dot=DEFNODE("Dot",null,{$documentation:"A dotted property access expression",_walk:function(b){return b._visit(this,function(){this.expression._walk(b)})}},AST_PropAccess),AST_Sub=DEFNODE("Sub",null,{$documentation:"Index-style property access, i.e. `a[\"foo\"]`",_walk:function(b){return b._visit(this,function(){this.expression._walk(b),this.property._walk(b)})}},AST_PropAccess),AST_Unary=DEFNODE("Unary","operator expression",{$documentation:"Base class for unary expressions",$propdoc:{operator:"[string] the operator",expression:"[AST_Node] expression that this unary operator applies to"},_walk:function(b){return b._visit(this,function(){this.expression._walk(b)})}}),AST_UnaryPrefix=DEFNODE("UnaryPrefix",null,{$documentation:"Unary prefix expression, i.e. `typeof i` or `++i`"},AST_Unary),AST_UnaryPostfix=DEFNODE("UnaryPostfix",null,{$documentation:"Unary postfix expression, i.e. `i++`"},AST_Unary),AST_Binary=DEFNODE("Binary","operator left right",{$documentation:"Binary expression, i.e. `a + b`",$propdoc:{left:"[AST_Node] left-hand side expression",operator:"[string] the operator",right:"[AST_Node] right-hand side expression"},_walk:function(b){return b._visit(this,function(){this.left._walk(b),this.right._walk(b)})}}),AST_Conditional=DEFNODE("Conditional","condition consequent alternative",{$documentation:"Conditional expression using the ternary operator, i.e. `a ? b : c`",$propdoc:{condition:"[AST_Node]",consequent:"[AST_Node]",alternative:"[AST_Node]"},_walk:function(b){return b._visit(this,function(){this.condition._walk(b),this.consequent._walk(b),this.alternative._walk(b)})}}),AST_Assign=DEFNODE("Assign",null,{$documentation:"An assignment expression \u2014 `a = b + 5`"},AST_Binary),AST_DefaultAssign=DEFNODE("DefaultAssign",null,{$documentation:"A default assignment expression like in `(a = 3) => a`"},AST_Binary),AST_Array=DEFNODE("Array","elements",{$documentation:"An array literal",$propdoc:{elements:"[AST_Node*] array of elements"},_walk:function(e){return e._visit(this,function(){for(var a=this.elements,b=0,c=a.length;b<c;b++)a[b]._walk(e)})}}),AST_Object=DEFNODE("Object","properties",{$documentation:"An object literal",$propdoc:{properties:"[AST_ObjectProperty*] array of properties"},_walk:function(e){return e._visit(this,function(){for(var a=this.properties,b=0,c=a.length;b<c;b++)a[b]._walk(e)})}}),AST_ObjectProperty=DEFNODE("ObjectProperty","key value",{$documentation:"Base class for literal object properties",$propdoc:{key:"[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",value:"[AST_Node] property value.  For getters and setters this is an AST_Accessor."},_walk:function(b){return b._visit(this,function(){this.key instanceof AST_Node&&this.key._walk(b),this.value._walk(b)})}}),AST_ObjectKeyVal=DEFNODE("ObjectKeyVal","quote",{$documentation:"A key: value object property",$propdoc:{quote:"[string] the original quote character"}},AST_ObjectProperty),AST_ObjectSetter=DEFNODE("ObjectSetter","quote static",{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] whether this is a static setter (classes only)"},$documentation:"An object setter property"},AST_ObjectProperty),AST_ObjectGetter=DEFNODE("ObjectGetter","quote static",{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] whether this is a static getter (classes only)"},$documentation:"An object getter property"},AST_ObjectProperty),AST_ConciseMethod=DEFNODE("ConciseMethod","quote static is_generator async",{$propdoc:{quote:"[string|undefined] the original quote character, if any",static:"[boolean] is this method static (classes only)",is_generator:"[boolean] is this a generator method",async:"[boolean] is this method async"},$documentation:"An ES6 concise method inside an object or class"},AST_ObjectProperty),AST_Class=DEFNODE("Class","name extends properties inlined",{$propdoc:{name:"[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",extends:"[AST_Node]? optional parent class",properties:"[AST_ObjectProperty*] array of properties"},$documentation:"An ES6 class",_walk:function(c){return c._visit(this,function(){this.name&&this.name._walk(c),this.extends&&this.extends._walk(c),this.properties.forEach(function(a){a._walk(c)})})}},AST_Scope),AST_DefClass=DEFNODE("DefClass",null,{$documentation:"A class definition"},AST_Class),AST_ClassExpression=DEFNODE("ClassExpression",null,{$documentation:"A class expression."},AST_Class),AST_Symbol=DEFNODE("Symbol","scope name thedef",{$propdoc:{name:"[string] name of this symbol",scope:"[AST_Scope/S] the current scope (not necessarily the definition scope)",thedef:"[SymbolDef/S] the definition of this symbol"},$documentation:"Base class for all symbols"}),AST_NewTarget=DEFNODE("NewTarget",null,{$documentation:"A reference to new.target"}),AST_SymbolDeclaration=DEFNODE("SymbolDeclaration","init",{$documentation:"A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"},AST_Symbol),AST_SymbolVar=DEFNODE("SymbolVar",null,{$documentation:"Symbol defining a variable"},AST_SymbolDeclaration),AST_SymbolBlockDeclaration=DEFNODE("SymbolBlockDeclaration",null,{$documentation:"Base class for block-scoped declaration symbols"},AST_SymbolDeclaration),AST_SymbolConst=DEFNODE("SymbolConst",null,{$documentation:"A constant declaration"},AST_SymbolBlockDeclaration),AST_SymbolLet=DEFNODE("SymbolLet",null,{$documentation:"A block-scoped `let` declaration"},AST_SymbolBlockDeclaration),AST_SymbolFunarg=DEFNODE("SymbolFunarg",null,{$documentation:"Symbol naming a function argument"},AST_SymbolVar),AST_SymbolDefun=DEFNODE("SymbolDefun",null,{$documentation:"Symbol defining a function"},AST_SymbolDeclaration),AST_SymbolMethod=DEFNODE("SymbolMethod",null,{$documentation:"Symbol in an object defining a method"},AST_Symbol),AST_SymbolLambda=DEFNODE("SymbolLambda",null,{$documentation:"Symbol naming a function expression"},AST_SymbolDeclaration),AST_SymbolDefClass=DEFNODE("SymbolDefClass",null,{$documentation:"Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."},AST_SymbolBlockDeclaration),AST_SymbolClass=DEFNODE("SymbolClass",null,{$documentation:"Symbol naming a class's name. Lexically scoped to the class."},AST_SymbolDeclaration),AST_SymbolCatch=DEFNODE("SymbolCatch",null,{$documentation:"Symbol naming the exception in catch"},AST_SymbolBlockDeclaration),AST_SymbolImport=DEFNODE("SymbolImport",null,{$documentation:"Symbol referring to an imported name"},AST_SymbolBlockDeclaration),AST_SymbolImportForeign=DEFNODE("SymbolImportForeign",null,{$documentation:"A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"},AST_Symbol),AST_Label=DEFNODE("Label","references",{$documentation:"Symbol naming a label (declaration)",$propdoc:{references:"[AST_LoopControl*] a list of nodes referring to this label"},initialize:function(){this.references=[],this.thedef=this}},AST_Symbol),AST_SymbolRef=DEFNODE("SymbolRef",null,{$documentation:"Reference to some symbol (not definition/declaration)"},AST_Symbol),AST_SymbolExport=DEFNODE("SymbolExport",null,{$documentation:"Symbol referring to a name to export"},AST_SymbolRef),AST_SymbolExportForeign=DEFNODE("SymbolExportForeign",null,{$documentation:"A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"},AST_Symbol),AST_LabelRef=DEFNODE("LabelRef",null,{$documentation:"Reference to a label symbol"},AST_Symbol),AST_This=DEFNODE("This",null,{$documentation:"The `this` symbol"},AST_Symbol),AST_Super=DEFNODE("Super",null,{$documentation:"The `super` symbol"},AST_This),AST_Constant=DEFNODE("Constant",null,{$documentation:"Base class for all constants",getValue:function(){return this.value}}),AST_String=DEFNODE("String","value quote",{$documentation:"A string literal",$propdoc:{value:"[string] the contents of this string",quote:"[string] the original quote character"}},AST_Constant),AST_Number=DEFNODE("Number","value literal",{$documentation:"A number literal",$propdoc:{value:"[number] the numeric value",literal:"[string] numeric value as string (optional)"}},AST_Constant),AST_RegExp=DEFNODE("RegExp","value",{$documentation:"A regexp literal",$propdoc:{value:"[RegExp] the actual regexp"}},AST_Constant),AST_Atom=DEFNODE("Atom",null,{$documentation:"Base class for atoms"},AST_Constant),AST_Null=DEFNODE("Null",null,{$documentation:"The `null` atom",value:null},AST_Atom),AST_NaN=DEFNODE("NaN",null,{$documentation:"The impossible value",value:0/0},AST_Atom),AST_Undefined=DEFNODE("Undefined",null,{$documentation:"The `undefined` value",value:function(){}()},AST_Atom),AST_Hole=DEFNODE("Hole",null,{$documentation:"A hole in an array",value:function(){}()},AST_Atom),AST_Infinity=DEFNODE("Infinity",null,{$documentation:"The `Infinity` value",value:1/0},AST_Atom),AST_Boolean=DEFNODE("Boolean",null,{$documentation:"Base class for booleans"},AST_Atom),AST_False=DEFNODE("False",null,{$documentation:"The `false` atom",value:!1},AST_Boolean),AST_True=DEFNODE("True",null,{$documentation:"The `true` atom",value:!0},AST_Boolean),AST_Await=DEFNODE("Await","expression",{$documentation:"An `await` statement",$propdoc:{expression:"[AST_Node] the mandatory expression being awaited"},_walk:function(b){return b._visit(this,function(){this.expression._walk(b)})}}),AST_Yield=DEFNODE("Yield","expression is_star",{$documentation:"A `yield` statement",$propdoc:{expression:"[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",is_star:"[Boolean] Whether this is a yield or yield* statement"},_walk:function(b){return b._visit(this,this.expression&&function(){this.expression._walk(b)})}});function TreeWalker(b){this.visit=b,this.stack=[],this.directives=Object.create(null)}TreeWalker.prototype={_visit:function(d,a){this.push(d);var b=this.visit(d,a?function(){a.call(d)}:noop);return!b&&a&&a.call(d),this.pop(),b},parent:function(b){return this.stack[this.stack.length-2-(b||0)]},push:function(b){b instanceof AST_Lambda?this.directives=Object.create(this.directives):b instanceof AST_Directive&&!this.directives[b.value]?this.directives[b.value]=b:b instanceof AST_Class&&(this.directives=Object.create(this.directives),!this.directives["use strict"]&&(this.directives["use strict"]=b)),this.stack.push(b)},pop:function(){var b=this.stack.pop();(b instanceof AST_Lambda||b instanceof AST_Class)&&(this.directives=Object.getPrototypeOf(this.directives))},self:function(){return this.stack[this.stack.length-1]},find_parent:function(e){for(var a,b=this.stack,c=b.length;0<=--c;)if(a=b[c],a instanceof e)return a},has_directive:function(f){var a=this.directives[f];if(a)return a;var b=this.stack[this.stack.length-1];if(b instanceof AST_Scope&&b.body)for(var c,d=0;d<b.body.length&&(c=b.body[d],!!(c instanceof AST_Directive));++d)if(c.value==f)return c},loopcontrol_target:function(e){var a=this.stack;if(e.label){for(var b,c=a.length;0<=--c;)if(b=a[c],b instanceof AST_LabeledStatement&&b.label.name==e.label.name)return b.body;}else for(var b,c=a.length;0<=--c;)if(b=a[c],b instanceof AST_IterationStatement||e instanceof AST_Break&&b instanceof AST_Switch)return b}};